# include "Tree.h"

    //THIS CONSTRUCTOR CREATES A TREE ONLY GOOD FOR DECOMPRESSION OF AN ALREADY COMPRESSED MESSAGE BY THIS VERY SAME TREE

    //no compression of a message is possible here since the table has been already built for some other message
    //to compress another message we must create another tree
    //one tree should compress only one message ,because a second message might contain letters the first one doesnt
    //and it would be impossible to compress those letters since they are not in the table or the tree

//This constructor is not used in the current version of the project
/**
 *@brief This constructor uses a Table and builds the tree from that table
         The tree generated by this constuctor is only good for decompression.A drawback of it is that the tree
         must be rebuild to some extend from the Table.All four non-deffault constructors work in a similliar way.The only differences
         between them being - how they get their string input, and wheter they use files.Look at three_constructor_three(...)
         it is the one used in the project and does not need to store a Table to save its work.
 *@see three_constructor_three(...)
 *@param given - a Table object that was alredy built , usually read from a binary file.
 *@date 20 01 2016
*/
Tree::Tree(const Table& given):Table::Table(),root(NULL),compressed_message(NULL),compressed_decimal_message(NULL){
    Table::operator=(given);
    message_length=0;
    compressed_message_length=0;
    compressed_decimal_message_length=0;
    if(get_count()==0){
        root=NULL;
        return;
    }
    //generating array of Vertices to work with
    int counter=get_count();
    Vertex* all_vertices_temporary=new Vertex [3*counter]; //all vertices <= 2* leaves
    for(int i=0;i<counter;i++){
        all_vertices_temporary[i]=*(get_start()+i);
    }
    sort_ascending_outclass(all_vertices_temporary,counter);
    int marked_vertices=0;

    int key_counter=Table::get_count();
    while(!(counter==marked_vertices+1)){//when counter==used_vertices+1 the only vertex with no parent is the root itself
        Vertex to_be_added; //we generate a generic vertex
        to_be_added.set_Node_ID((++key_counter));
        to_be_added.set_left_successor(NULL);
        to_be_added.set_right_successor(NULL);
        to_be_added.set_repetitions(0);
        to_be_added.set_letter('Ù');
        to_be_added.set_code(NULL,0);
        to_be_added.set_code_length(0);
        to_be_added.set_marked(false);
        to_be_added.set_right_successor(find_unmarked_min_outclass(all_vertices_temporary,counter));//we assign its right successor to be the minimum vertex that has not been used yet
        int right_repetitions=(find_unmarked_min_outclass(all_vertices_temporary,counter))->get_repetitions();//memorizing right repetitions
        (find_unmarked_min_outclass(all_vertices_temporary,counter))->set_marked(true);//we mark the just used vertex as used
        to_be_added.set_marked(true);//we mark the generic vertex as used so as not to include it in the search for the next minimum unused vertex
        to_be_added.set_left_successor(find_unmarked_min_outclass(all_vertices_temporary,counter));//we assign a left successor
        int left_repetitions=(find_unmarked_min_outclass(all_vertices_temporary,counter))->get_repetitions();//memorizing left repetitions
        (find_unmarked_min_outclass(all_vertices_temporary,counter))->set_marked(true);//we mark the just found vertex as used
        to_be_added.set_marked(false);//the generic vertex has finally been built and we can mark it as unused and can use it in the next cycle
        int sum=left_repetitions+right_repetitions;//generating repetitions for the new vertex
        to_be_added.set_repetitions(sum);
        if((counter+1)==(marked_vertices+2)+1){//if it is the last iteration this is the root, give it NODE_ID 0
            to_be_added.set_Node_ID(0);
        }
        all_vertices_temporary[counter]=to_be_added;
        counter+=1;
        marked_vertices+=2;//we ve just added 2 vertices, when (all vertices=used vertices+1) we stop the cycle
    }
    //after we 've finished finding all the vertecies for the tree,we unmark all of them
    //for future needs;
    for (int i=0;i<counter;i++){
        (all_vertices_temporary+i)->set_marked(false);
    }
    //we copy the tree we ve just built in the array in the root
    root=copy_tree((find_max_outclass(all_vertices_temporary,counter)));
    //now we delete the array because we have the tree
    delete [] all_vertices_temporary;
}
